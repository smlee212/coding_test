엘리스 토끼는 친구들과 함께 미로 탈출 게임을 하기로 했습니다. 게임은 미로를 탈출하는데 가장 적은 칸을 지나간 사람이 이기는 방식으로 진행됩니다.

미로는 N * N 크기의 배열로 구성되어 있습니다.
미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타냅니다.

이러한 미로가 주어졌을 때, 출발지 (1, 1)에서 도착지 (N, N)의 위치로 이동할 때 지나야 하는 최소 칸의 수를 구하는 프로그램을 작성해 봅시다.

칸을 셀 때는 시작 위치와 도착 위치도 포함됩니다.

예를 들어 5 * 5 미로가 다음과 같이 주어졌을 경우

10111
10101
10101
10101
11111

다음이 최소의 칸을 지나는 경로이므로

1 0 1 1 1
1 0 1 0 1
1 0 1 0 1
1 0 1 0 1
1 1 1 1 1

9가 출력됩니다.
//
입력
첫째 줄에 정수 N이 주어집니다.
(2 ≤ N ≤ 50)
(2≤N≤50)
둘째 줄부터 N+1개의 줄에는 0과 1로 구성된 N개의 미로가 주어지며, 각각의 수들은 붙어있어야 합니다.
항상 도착 위치로 이동할 수 있는 경우만 입력으로 주어집니다.
//
출력
도착할 때까지 지나가야 하는 최소 칸의 수가 출력됩니다.
//
입력 예시Ⅰ
5
10111
10101
10101
10101
11111

출력 예시Ⅰ
9
//

입력 예시Ⅱ
10
1111111111
0000000001
0000000001
0000000001
0000000001
0000000001
0000000001
0000000001
0000000001
0000000001

출력 예시
19

//////////////////////////////////////////////////////

#include <bits/stdc++.h>
using namespace std;
#define endl '\n'

#define MAX 50
int n;
int graph[MAX][MAX] = { 0, };

int dx[] = { -1, 1, 0, 0 };
int dy[] = { 0, 0, -1, 1 };

int bfs(int x, int y) {
	queue<pair<int, int>> q;
	q.push({ x,y });
	while (!q.empty()) {
		int x = q.front().first;
		int y = q.front().second;
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i];
			int ny = y + dy[i];

			if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
				continue;
			}

			if (graph[nx][ny] == 0) {
				continue;
			}
			
			if (graph[nx][ny] == 1) {
				graph[nx][ny] = graph[x][y] + 1;
				q.push({ nx,ny });
			}
		}
	}
	return graph[n - 1][n - 1];
}


int main() {
	//ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%1d", &graph[i][j]);
		}
	}
	cout << bfs(0, 0) << endl;

	return 0;
}